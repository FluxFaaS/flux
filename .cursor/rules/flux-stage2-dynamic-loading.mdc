---
alwaysApply: true
---
# FluxFaaS Stage 2 - Dynamic Function Loading Rules

## 项目概述
FluxFaaS 是一个轻量级私有 Serverless 平台，基于 Rust 和 Silent 框架构建。
**第一阶段 MVP 已完成** ✅，当前进入第二阶段，专注于实现动态函数加载和管理功能。

## 第二阶段核心目标

### 当前阶段重点
- 支持动态加载函数代码
- 建立完善的函数注册机制
- 实现内存缓存优化性能
- 为第三阶段的调度优化做好准备

### 第二阶段开发顺序
严格按以下顺序进行开发：

1. **改进函数注册机制** 🎯
   - 支持从文件动态加载函数代码
   - 支持从字符串直接注册函数
   - 增强函数元数据管理
   - 实现函数代码验证机制

2. **实现内存缓存机制** 🚀
   - 缓存函数编译结果
   - 优化函数执行性能
   - 实现缓存失效策略
   - 内存使用监控和限制

3. **优化动态加载的性能和安全性** 🔒
   - 函数代码沙箱执行
   - 安全性检查和限制
   - 性能监控和优化
   - 错误处理完善

## 架构约束（继承第一阶段）

### 必须保持的约束
- 必须使用 Silent 框架作为 web 服务基础
- 遵循现有目录结构：`gateway/`, `scheduler/`, `runtime/`, `functions/`
- 每个模块保持独立，通过清晰的接口通信
- 优先使用 Rust 标准库和成熟的 crate

### 新增技术栈（第二阶段）
- **函数编译**: 考虑使用 `proc-macro2` 或简单的代码生成
- **缓存**: 使用 `dashmap` 或 `lru` 进行内存缓存
- **文件监控**: 使用 `notify` 监控函数文件变化
- **代码解析**: 继续优化现有的简单解析器

## 代码规范（第二阶段扩展）

### 新增文件组织
```
src/
├── runtime/
│   ├── loader.rs     # 动态函数加载器 ⭐ NEW
│   ├── cache.rs      # 函数缓存管理 ⭐ NEW
│   └── validator.rs  # 函数代码验证 ⭐ NEW
├── functions/
│   ├── storage.rs    # 函数存储后端 ⭐ NEW
│   └── watcher.rs    # 文件变化监控 ⭐ NEW
└── examples/
    └── functions/    # 示例函数目录 ⭐ NEW
```

### 新增错误类型
```rust
#[derive(Debug, thiserror::Error)]
pub enum FluxError {
    // 现有错误类型...

    // 第二阶段新增
    #[error("Function compilation failed: {0}")]
    CompilationError(String),
    #[error("Function validation failed: {reason}")]
    ValidationError { reason: String },
    #[error("Cache error: {0}")]
    CacheError(String),
    #[error("File system error: {0}")]
    FileSystemError(#[from] std::io::Error),
}
```

## 功能要求（第二阶段）

### ✅ 第一阶段 - 基础调用（已完成）
- ✅ 启动 Silent web 服务
- ✅ 接收 POST `/invoke/{function_name}` 请求
- ✅ 执行预定义的 Rust 函数
- ✅ 返回执行结果
- ✅ 交互式 CLI 界面
- ✅ SCRU128 ID 系统

### 🎯 第二阶段 - 函数管理（当前开发中）
- [ ] **动态函数加载**
  - [ ] 从文件加载函数代码
  - [ ] 运行时注册新函数
  - [ ] 函数热更新机制

- [ ] **函数注册机制**
  - [ ] 增强的函数元数据
  - [ ] 函数依赖管理
  - [ ] 版本控制支持

- [ ] **内存缓存**
  - [ ] 函数编译结果缓存
  - [ ] LRU 缓存策略
  - [ ] 缓存统计和监控

### 🔮 第三阶段 - 调度优化（未来规划）
- [ ] 函数实例管理
- [ ] 基础的负载均衡
- [ ] 错误处理和重试

## 第二阶段性能要求
- 动态加载函数时间 < 200ms
- 缓存命中率 > 80%
- 内存使用增量 < 50MB
- 支持并发函数注册

## 第二阶段开发原则

### 1. 渐进增强
- 在现有功能基础上增强，不破坏已有功能
- 保持向后兼容性
- 每个功能都要有降级方案

### 2. 安全优先
- 函数代码验证必须严格
- 资源使用限制
- 错误隔离机制

### 3. 性能感知
- 缓存策略要合理
- 内存使用要可控
- 实现性能监控

## 第二阶段开发提示
1. 优先实现功能，再优化性能
2. 每个子功能完成后立即测试
3. 保持现有 CLI 界面可用
4. 实现过程中多做 commit
5. 注意内存泄露问题
6. 关注函数加载的安全性

## 第二阶段禁止事项
- 不要破坏第一阶段已完成的功能
- 不要引入过于复杂的依赖
- 不要忽略安全性检查
- 不要实现第三阶段的功能（保持专注）
- 不要偏离当前的开发顺序
description:
globs:
alwaysApply: false
---
